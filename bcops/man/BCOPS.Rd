% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BCOPS.R
\name{BCOPS}
\alias{BCOPS}
\title{BCOPS function that does both training and prediction.}
\usage{
BCOPS(classifier, x1, y1, xte1, x2, y2, xte2, labels, formula = FALSE,
  prediction_only = TRUE, name = "predictions", ...)
}
\arguments{
\item{classifier}{a user-specified classifier. Note that the classifier can either takes input as feature matrix x and response y, or a dataframe contains features and response and a formula.}

\item{x1}{n1 by p feature matrix for the first fold of training data.}

\item{y1}{length n1 class labels for the first fold of training data.}

\item{xte1}{m1 by p feature matrix for the first fold of test data.}

\item{x2}{n1 by p feature matrix for the first fold of training data.}

\item{y2}{length n1 class labels for the first fold of training data.}

\item{xte2}{m2 by p feature matrix for the first fold of test data.}

\item{labels}{labels for the K training classes.}

\item{formula}{boolean variable indicating if the classifier takes data argument as classifier(formula, data,...) or  classifier(x, y,...). The function ranger is an example of the former, and the function cv.glmnet is an example of the later.}

\item{prediction_only}{boolean variable indicating whether predict(classifier,...) returns directly the predictions (TRUE) or need to be accessed by a specific name.}

\item{name}{the name we can use to access the predictions. By default, name = "predictions".}

\item{...}{other arguments depending on the classifier. Note the argument is applied to the augmented data by stacking x and xte together when building a binary classifier.}
}
\value{
conformal.scores1: The m1 by K conformal scores for the first fold of test samples xte1.

conformal.scores2: The m2 by K conformal scores for the second fold of test samples xte2.
}
\description{
BCOPS function that does both training and prediction.
}
\examples{
\dontrun{
data(mnist); 
xtrain = mnist[['data']][['x']]; ytrain = mnist[['data']][['y']]; 
xtest = mnist[['data_te']][['x']]; ytest=mnist[['data_te']][['y']]; 
########split the training and test data into two halfs for conformal prediction##############
set.seed(123)
foldid = sample(1:2, length(ytrain), replace = TRUE); foldid_te = sample(1:2,length(ytest), replace = TRUE)
xtrain1 = xtrain[foldid==1,]; xtrain2 = xtrain[foldid==2,]; ytrain1 = ytrain[foldid==1]; ytrain2=ytrain[foldid==2]
xtest1 = xtest[foldid_te ==1,]; xtest2 = xtest[foldid_te==2,]; 
labels = sort(unique(ytrain)) 
#########example using cv.glmnet##############
 require(glmnet)
 bcops1 = BCOPS(cv.glmnet, xtrain1, ytrain1, xtest1, 
                 xtrain2, ytrain2, xtest2, labels, formula = FALSE)
#########example using random forest##########
 require(ranger)
 bcops2 = BCOPS(ranger, xtrain1, ytrain1, xtest1, xtrain2, ytrain2, xtest2, labels, formula = TRUE, prediction_only = FALSE)
 }
}
