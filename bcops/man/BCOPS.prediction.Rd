% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BCOPSprediction.R
\name{BCOPS.prediction}
\alias{BCOPS.prediction}
\title{BCOPS prediction function}
\usage{
BCOPS.prediction(models, x, y, labels, xte, formula = FALSE,
  prediction_only = TRUE, name = "predictions")
}
\arguments{
\item{models}{a list of models calculating the predicted $v_k(x)$ for each class, it is an object from BCOPS.train.}

\item{x}{n by p feature matrix for the training data to be used in conformal inference.}

\item{y}{length n class labels for the training data to be used in the conformal inference.}

\item{labels}{Labels for the K classes when applying BCOPS.train.}

\item{xte}{m by p features for the test data to be used in the conformal inference.}

\item{formula}{boolean variable indicating if the classifier takes data argument as classifier(formula, data,...) or  classifier(x, y,...). The function ranger is an example of the former, and the function cv.glmnet is an example of the later.}

\item{prediction_only}{boolean variable indicating whether predict(classifier,...) returns directly the predictions (TRUE) or need to be accessed by a specific name.}

\item{name}{the name we can use to access the predictions. By default, name = "predictions".}
}
\value{
prediction.conformal a m by K matrix for m test samples, it is the conformal constructed p-value for a test sample not from each of the K classes. If we want to control the type I error at alpha, then, we assign all class labels whose conformal p-value is no smaller than alpha to the test samples.

scores_test a m by K matrix for m test samples and K classes, each entry is the value evaluated at a test sample using score function for a training class.

scores_train a n by K matrix for n training samples, each entry is the value evaluated at a training sample using score function for a training class.
}
\description{
BCOPS prediction function
}
\examples{
\dontrun{
data(mnist);
xtrain = mnist[['data']][['x']]; ytrain = mnist[['data']][['y']];
xtest = mnist[['data_te']][['x']]; ytest=mnist[['data_te']][['y']];
########split the training and test data into two halfs for conformal prediction##############
set.seed(123)
foldid = sample(1:2, length(ytrain), replace = TRUE); foldid_te = sample(1:2,length(ytest), replace = TRUE)
xtrain1 = xtrain[foldid==1,]; xtrain2 = xtrain[foldid==2,]; ytrain1 = ytrain[foldid==1]; ytrain2=ytrain[foldid==2]
xtest1 = xtest[foldid_te ==1,]; xtest2 = xtest[foldid_te==2,];
labels = sort(unique(ytrain))
#########example using cv.glmnet##############
 require(glmnet)
 models1 = BCOPS.train(cv.glmnet, xtrain2, ytrain2, labels, xtest2)
 prediction.conformal1 = BCOPS.prediction(models = models1, xtrain1, ytrain1, labels , xtest1)$prediction.conformal
 models2 = BCOPS.train(cv.glmnet, xtrain1, ytrain1, labels, xtest1)
 prediction.conformal2 = BCOPS.prediction(models = models2, xtrain2, ytrain2, labels , xtest2)$prediction.conformal
#########example using random forest##########
 require(ranger)
 models1 = BCOPS.train(ranger, xtrain2, ytrain2, labels, xtest2, formula = TRUE)
 prediction.conformal1 = BCOPS.prediction(models = models1, xtrain1, ytrain1, labels , xtest1, formula = TRUE, prediction_only = FALSE)$prediction.conformal
 models2 = BCOPS.train(ranger, xtrain1, ytrain1, labels, xtest1, formula = TRUE)
 prediction.conformal2 = BCOPS.prediction(models = models2, xtrain2, ytrain2, labels , xtest2,formula = TRUE, prediction_only = FALSE)$prediction.conformal
 }
}
